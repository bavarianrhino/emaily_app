const _ = require('lodash')
const { Path } = require('path-parser')

// Integrated Mod in Node - Has a large library with helpers 
const { URL } = require('url')

// Sometimes when you use mongoose with testing framework it will complain if you call in a model multiple times
const mongoose = require('mongoose')

const requireLogin = require('../middlewares/requireLogin');
const requireCredits = require('../middlewares/requireCredits');
const Mailer = require('../services/Mailer')
const surveyTemplate = require('../services/emailTemplates/surveyTemplate')

// Added for testing framework scalability
const Survey = mongoose.model('surveys');

module.exports = app => {

    app.get('/api/surveys/thankyou', (req, res) => {
        res.send("Thanks for the feedback!")
    })
   
    // REFACTORED SEE VERBOSE POST BELOW
    // CHAIN IS AN ADVANCED LODASH FUNCTION ALLOWING US TO CHAIN A MAP, COMPACT & UNIQBY
    app.post('/api/surveys/webhooks', (req, res) => {
        const p = new Path('/api/surveys/:surveyId/:choice')

        _.chain(req.body)
            .map(({ email, url }) => {
                const match = p.test(new URL(url).pathname)
                if (match) {
                    return { email, surveyId: match.surveyId, choice: match.choice }
                }
            })
            .compact()
            .uniqBy('email', 'surveyId')
            .each(({ surveyId, email, choice }) => { //.each(event => {
                Survey.updateOne(
                    {
                        _id: surveyId,
                        recipients: {
                            $elemMatch: { email: email, responded: false }
                        }
                    },
                    {
                        $inc: { [choice]: 1 },
                        $set: { 'recipients.$.responded': true },
                        lastResponded: new Date()
                    }
                ).exec();
            })
            .value();
        res.send({});
    })


    // SURVEY POST
    // 2 things to vet about user before hooking up.
    // first user needs to be logged in and authenticated - use middleware 
    // second that user has enough credits 
    // After testing full email post, we then complete it as an async process because we do not want to save the survey,
    // until we verify that all emails provided are 'good' and that they were all sent.
    
    app.post('/api/surveys', requireLogin, requireCredits, async (req, res) => {
        const { title, subject, body, recipients } = req.body;

         // Model class creates an instance of a survey and not persisted to the database...to save it, gotta call save()
         // Sub-Document collection of recipients - array of objects containing users email with responded property defaulting to false
        //    Take list of emails and use split to give us an array of strings and then map over it to assign in a object
        const survey = new Survey({
            title: title, //ES6 can reduce it down to just title
            subject: subject,
            body: body,
            recipients: recipients.split(',').map(email => { return { email: email.trim() }}),
            _user: req.user.id,
            dateSent: Date.now() 
        })

        // Good place to send an email
        // First arg is a object with subject property and a recipients property
        // Second arg is an object containing HTML to use in body of email 
        const mailer = new Mailer(survey, surveyTemplate(survey));

        // Below code creates multiple opportunites for errors
        // Implement catch all error to notify user
        try {
            await mailer.send(); // Once mailer has sent all surveys successfully we then save that survey
            await survey.save();

            // Once survey is successfully saved, we know one credit was successfully used so we subtract from users credits
            // and then we update user.
            req.user.credits -= 1;
            const user = await req.user.save(); //Wait to save and receive new updated user
            res.send(user); //Sending back user model here so that a users credits is automatically updated.
        } catch (error) {
            res.status(422).send(error)
        }
    })
};
// ES6 Reduces to = recipients: recipients.split(',').map(email => ({ email })
// _user: req.user.id - The id is automatically generated by mongoose model

// VERBOSE POST
// https://BrEaDtUnNeL_ApI_RiEsRyA.localtunnel.me/api/surveys/webhooks
// app.post('/api/surveys/webhooks', (req, res) => {
//     console.log(req.body)
//     const events = _.map(req.body, (event) => {
// const events = _.map(req.body, ({ email, url }) => {
//     URL, built in mod to Node will take 'http://localhost:3000/api/surveys/5db8b4fdb43af3470b28452e/yes',
//     and return api/surveys/5db8b/yes
// const pathname = new URL(url).pathname;
//     Path is the parser mod we have brought in for the main purpose to extract
// const p = new Path('/api/surveys/:surveyId/:choice')
//     console.log(p.test()) = null
//     console.log(p) will throw an error
//     console.log(p.test(pathname)
// const match = p.test(pathname)
// if (match) {
// return { email, surveyId: match.surveyId, choice: match.choice }
// }
// })
// const compactEvents = _.compact(events)
// const uniqueEvents = _.uniqBy(compactEvents, 'email', 'surveyId')
//     uniqBy will allow a similar user vote on two surveyId....
//     console.log(uniqueEvents)
//     Logic here is suppose to pair down our events
//     This is suppose to tell sendgrid that we're fine, stop force pinging us
// res.send({});
// })
//====================================================================//
// REFACTOR AGAIN
// app.post('/api/surveys/webhooks', (req, res) => {

//     const events = _.map(req.body, ({ email, url }) => {
//         const p = new Path('/api/surveys/:surveyId/:choice')
//         const match = p.test(new URL(url).pathname)
//         if (match) {
//             return { email, surveyId: match.surveyId, choice: match.choice }
//         }
//     })

//     const compactEvents = _.compact(events)
//     const uniqueEvents = _.uniqBy(compactEvents, 'email', 'surveyId')

//     res.send({});
// })
//====================================================================//
// REFACTOR AGAIN
// app.post('/api/surveys/webhooks', (req, res) => {
//     const p = new Path('/api/surveys/:surveyId/:choice')

//     const events = _.chain(req.body)
//         .map(({ email, url }) => {
//             const match = p.test(new URL(url).pathname)
//             if (match) {
//                 return { email, surveyId: match.surveyId, choice: match.choice }
//             }
//         })
//         .compact()
//         .uniqBy('email', 'surveyId')
//         .value();

//     console.log(events)
//     res.send({});
// })